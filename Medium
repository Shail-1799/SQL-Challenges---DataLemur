Challenge Name: Highest-Grossing Items

WITH t as(
  SELECT  category, product, 
  SUM(spend) as total_spend
  FROM product_spend
  WHERE EXTRACT(YEAR from transaction_date) = '2022'
  GROUP BY category, product
),

t1 as(
  SELECT *,
  RANK() OVER (partition by category order by total_spend Desc) as ranking
  FROM t
)

SELECT category, product, total_spend
FROM t1 
WHERE ranking < 3;


============================================================================================

Challenge Name: Repeat Purchases on Multiple Days

SELECT Count(Distinct user_id) as num_user
FROM 
(SELECT user_id, product_id, Count(Distinct DATE(purchase_date)) 
FROM purchases
GROUP BY user_id, product_id
HAVING Count(Distinct DATE(purchase_date)) > 1) as t;


--- OR --- Using CTE and Rank() ----

WITH ranking AS (
  SELECT 
    user_id, 
    RANK() OVER (PARTITION BY user_id, product_id 
      ORDER BY DATE(purchase_date) ASC
    ) AS purchase_no 
  FROM 
    purchases
) 
SELECT 
  COUNT(DISTINCT user_id) AS users_num 
FROM 
  ranking 
WHERE 
  purchase_no = 2;


============================================================================================

Challenge Name: Compensation Outliers

WITH t as (
  SELECT *,
  AVG(salary) OVER(partition by title) as avg_sal
  FROM employee_pay
)

SELECT employee_id, salary,
CASE WHEN salary > 2 * avg_sal THEN 'Overpaid'
     WHEN salary < 0.5 * avg_sal THEN 'Underpaid'
     END as status
FROM t  
WHERE salary > 2 * avg_sal OR salary < 0.5 * avg_sal;  

============================================================================================

Challenge Name: User's Third Transaction

SELECT user_id, spend, transaction_date
FROM (SELECT *, 
  RANK() OVER(partition by user_id order by transaction_date) as trans_num
  FROM transactions) t
WHERE trans_num = 3

============================================================================================

Challenge Name: Purchasing Activity by Product Type

Solution:
SELECT order_date, product_type,
Sum(quantity) OVER (partition by product_type ORDER BY order_date) as cum_purchased
FROM total_trans
ORDER BY order_date;

============================================================================================

Challenge Name: Sending Vs. opening Snaps

SELECT 
age_bucket,
ROUND(SUM(CASE WHEN activity_type = 'send' THEN time_spent ELSE 0 END)*100/
  SUM(CASE WHEN activity_type <> 'chat' THEN time_spent ELSE 0 END), 2) as send_perc,
ROUND(SUM(CASE WHEN activity_type = 'open' THEN time_spent ELSE 0 END)*100/
  SUM(CASE WHEN activity_type <> 'chat' THEN time_spent ELSE 0 END), 2) as open_perc
FROM activities a INNER JOIN age_breakdown b on a.user_id = b.user_id
GROUP BY age_bucket;
============================================================================================

Challenge Name: Odd and Even Measurements

WITH t as (
  SELECT *,
  ROW_NUMBER() OVER(PARTITION BY DATE_PART('day', measurement_time) ORDER BY measurement_time) as num_m
  FROM measurements
)

SELECT DATE(measurement_time),
SUM(CASE WHEN num_m%2 <> 0 THEN measurement_value ELSE 0 END) as odd_sum,
SUM(CASE WHEN num_m%2 = 0 THEN measurement_value ELSE 0 END) as even_sum
FROM t
GROUP BY DATE(measurement_time)
ORDER BY DATE(measurement_time);

============================================================================================

Challenge Name: Frequently Purchased Pairs

WITH purchases as (
  SELECT transaction_id, t.product_id, product_name 
  FROM transactions t INNER JOIN products p 
  ON t.product_id = p.product_id
)

SELECT p1.product_name, p2.product_name, COUNT(*) as combo_num
FROM purchases p1 INNER JOIN purchases p2
ON p1.transaction_id = p2.transaction_id
AND p1.product_id > P2.product_id
GROUP BY p1.product_name, p2.product_name
ORDER BY combo_num DESC
LIMIT 3;

============================================================================================

Challenge Name: First Transaction

WITH t as (
  SELECT *,
  RANK() OVER(PARTITION BY user_id ORDER BY transaction_date, transaction_id) as t_rank
  FROM user_transactions
)

SELECT COUNT(user_id)
FROM T 
WHERE t_rank = 1 
AND spend > 50.0;
